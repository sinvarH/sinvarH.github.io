<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="JMM Java线程间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程课件，JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。 JMM属于语言级的内存模型，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程艺术">
<meta property="og:url" content="http://yoursite.com/2017/10/10/Java并发编程艺术/index.html">
<meta property="og:site_name" content="sinvar笔记">
<meta property="og:description" content="JMM Java线程间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程课件，JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。 JMM属于语言级的内存模型，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/bfb7238e790b4bfa8eb1a5522207de2e/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/776e951de2d041a8a11583897f59ead6/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/5df3476e025b428ca3bfc1250693cb6c/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/2304ffd78d184a6f84a6f35a4ec2fc8c/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/d11f9365ebb848ed81922fa00b073e61/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/63e6f0365f2542c58f2d55b7ddc6094b/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/c1c8cee107a743ed982f897c32aeb9cf/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9ba06559c5b145adbbc5ac197225ed03/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/bfdd4e18c5fc45b29567e227f3ac5501/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9904e58062334f1fb82dbfb1e92bc3ee/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9f4bbefa6af647c39f3ca1f843e956ce/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/050172b8264242efbe768a9daf5d83b1/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/1076ddd4a8c54c58af5c6eae512db615/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/acab4c6bd9374b56b2b7667e30583514/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/415bddd0f0a04e268594f25f0fa6464b/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/26d5cb5726424f448b1bc0f72c62f932/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/46883a882c694ee6a9f826c2c3bd5ecb/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/d0fcf90b4f22412ca8310e329a442942/clipboard.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/3e1d05620c68456b8cb44949c74a8960/clipboard.png">
<meta property="og:updated_time" content="2017-10-10T15:16:48.014Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程艺术">
<meta name="twitter:description" content="JMM Java线程间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程课件，JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。 JMM属于语言级的内存模型，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型">
<meta name="twitter:image" content="c:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/bfb7238e790b4bfa8eb1a5522207de2e/clipboard.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/10/Java并发编程艺术/"/>





  <title>Java并发编程艺术 | sinvar笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sinvar笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/Java并发编程艺术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sinvar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sinvar笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java并发编程艺术</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-10T23:13:18+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JMM</p>
<p>Java线程间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程课件，JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<p>JMM属于语言级的内存模型，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障分为4类</p>
<p>loadload barriers </p>
<p>storestore barriers</p>
<p>loadstore barriers</p>
<p>storeload barriers </p>
<p>storeload 是也个“全能型”的屏障，他同时具有其他三个屏障的效果，先代的多处理器大多支持该屏障。</p>
<p>happens-before ：</p>
<p>Java使用jsr-133内存模型</p>
<p>jrs-133 使用happens-before 的概念来阐述操作之间的内存可见性。如果一个操作执行结果需要对另一个操作可见，那么这两个操作之间必须存在happen-before关系</p>
<p>happens-before几条重要规则：</p>
<p>一个线程中的每个操作，happens-before 该线程中任意后序操作</p>
<p>unlock happens-before lock</p>
<p>volatile写 happens-before volatile读</p>
<p>传递性 A happens-before B B happens-before C ，那么 A happens-before C</p>
<p>volatile的内存语义 ：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</p>
<p>JMM内存语义的实现</p>
<p>在每个volatile写前插入StoreSotre屏障</p>
<p>在每个volatile写后插入StoreLoad屏障</p>
<p>在每个volatile写前插入LoadSotre屏障</p>
<p>在每个volatile写后插入LoadStore屏障</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/bfb7238e790b4bfa8eb1a5522207de2e/clipboard.png" alt="img"></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/776e951de2d041a8a11583897f59ead6/clipboard.png" alt="img"></p>
<p>Class文件 —JVM 翻译成字节码指令— c - 汇编 - 01 （这顺序后面3个不知道对不对）</p>
<p>JVM <a href="https://www.zhihu.com/question/20163831/answer/18629722" target="_blank" rel="external">https://www.zhihu.com/question/20163831/answer/18629722</a></p>
<p>Oracle/Sun HotSpot VM - 整体都是用C++实现的，只有非常少量的内嵌汇编</p>
<p>深入理解Java 虚拟机p370 </p>
<p>加入volatile 时候多出了 lock add $0x0,(%esp)这条汇编指令</p>
<p>这个操作的作用相当于一个内存屏障</p>
<p>内存屏障的实现  维基百科 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C</a></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/5df3476e025b428ca3bfc1250693cb6c/clipboard.png" alt="img"></p>
<p>锁的内存语义： 当线程释放锁是，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。（和volatile一样）</p>
<p>ReentrantLock实现</p>
<p>lock的时候 先读volatile变量state</p>
<p>unlock 时候 最后才写 volatile变量state</p>
<p>根据 volatile happens-before 和 传递性 </p>
<p>volatile 写前 happens-nefore volatile读后</p>
<p>公平锁的 lock()调用轨迹如下</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/2304ffd78d184a6f84a6f35a4ec2fc8c/clipboard.png" alt="img"></p>
<p>第四布真正加锁</p>
<p>公平锁 unlock</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/d11f9365ebb848ed81922fa00b073e61/clipboard.png" alt="img"></p>
<p>第三步真正开始释放锁</p>
<p>非公平锁</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/63e6f0365f2542c58f2d55b7ddc6094b/clipboard.png" alt="img"></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/c1c8cee107a743ed982f897c32aeb9cf/clipboard.png" alt="img"></p>
<p>单例双重检查锁</p>
<p>private state Instance instance;</p>
<p>public static Instance getInstance(){</p>
<p>if(instance==null){</p>
<p>synchronized(DoubuleCheckedLocking.class){</p>
<p>if(instance == null){</p>
<p>instance = new Instance();</p>
<p>}</p>
<p>}</p>
<p>return instance;</p>
<p>}</p>
<p>}</p>
<p>没有声明为volatile的话可能初始话的时候重排序导致错误</p>
<p>Lock 接口 API</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9ba06559c5b145adbbc5ac197225ed03/clipboard.png" alt="img"></p>
<p>Jmm是一个语言级的内存模型</p>
<p>java的内存可见保证学可以分为这三类：</p>
<p>1.- 单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确</p>
<p>保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p>
<p>2.- 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行</p>
<p>结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限</p>
<p>制编译器和处理器的重排序来为程序员提供内存可见性保证。</p>
<p>3.-·未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取</p>
<p>到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</p>
<p>线程</p>
<p>为什么使用多线程</p>
<p>1.更多的处理器核心</p>
<p>2.更快的响应时间</p>
<p>3.更好的编程模型</p>
<p>线程的状态</p>
<p> new runnable blocked（阻塞于锁） waiting time-waiting terminated</p>
<p>Daemon线程</p>
<p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这</p>
<p>意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调</p>
<p>用Thread.setDaemon(true)将线程设置为Daemon线程。</p>
<p>构造线程</p>
<p>thread 的初始化</p>
<p>private void init(ThreadGroup g, Runnable target, String name,long stackSize,</p>
<p>AccessControlContext acc) {</p>
<p>if (name == null) {</p>
<p>throw new NullPointerException(“name cannot be null”);</p>
<p>}</p>
<p>// 当前线程就是该线程的父线程</p>
<p>Thread parent = currentThread();</p>
<p>this.group = g;</p>
<p>// 将daemon、priority属性设置为父线程的对应属性</p>
<p>this.daemon = parent.isDaemon();</p>
<p>this.priority = parent.getPriority();</p>
<p>this.name = name.toCharArray();</p>
<p>this.target = target;</p>
<p>setPriority(priority);</p>
<p>// 将父线程的InheritableThreadLocal复制过来</p>
<p>if (parent.inheritableThreadLocals != null)</p>
<p>this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.</p>
<p>inheritableThreadLocals);</p>
<p>// 分配一个线程ID</p>
<p>tid = nextThreadID();</p>
<p>}</p>
<p>在上述过程中，一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程</p>
<p>继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的</p>
<p>ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对</p>
<p>象就初始化好了，在堆内存中等待着运行。</p>
<p>启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程</p>
<p>序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</p>
<p>中断</p>
<p><a href="http://blog.csdn.net/canot/article/details/51087772" target="_blank" rel="external">http://blog.csdn.net/canot/article/details/51087772</a></p>
<p>（在Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 ）</p>
<p>不是所有的阻塞方法收到中断后都可以取消阻塞状态, 输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会退出阻塞状态. </p>
<p>详情google </p>
<p>-————————————-</p>
<p>中断可以理解为程序的一个标识位属性，他表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过对该线程的interrupt（）方法对其进行中断操作</p>
<p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted（）来进行判断是否被中断，</p>
<p>也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该相册已经处于结束状态。</p>
<p>suspend()、resume()和stop()方法完成了线程的暂停、恢复和终</p>
<p>止工作，而且非常“人性化”。但是这些API是过期的，也就是不建议使用的。</p>
<p> 不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资</p>
<p>源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结</p>
<p>一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，</p>
<p>因此会导致程序可能工作在不确定状态下。</p>
<p>线程间的通信</p>
<p> volatile synchonized </p>
<p>等待/通知机制 </p>
<p>等待方：</p>
<p>synchronized(对象) {</p>
<p>while(条件不满足) {</p>
<p>对象.wait();</p>
<p>}</p>
<p>对应的处理逻辑</p>
<p>}</p>
<p>通知方</p>
<p>synchronized(对象) {</p>
<p>改变条件</p>
<p>对象.notifyAll();</p>
<p>}’</p>
<p>等待超时模式就是在等待/通知范式基础上增加了超时控制</p>
<p>管道输入/输出流</p>
<p>thread.join()</p>
<p>threadlocal 的使用  使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值(线程初始化的时候会传进去)。<a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html</a> </p>
<p>getmap 然后再</p>
<p><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="external">深入分析 ThreadLocal 内存泄漏问题</a></p>
<p>Java中的锁</p>
<p>Lock 接口</p>
<p>Lock接口提供的synchronized关键字所不具备的主要特性如表5-1所示。</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/bfdd4e18c5fc45b29567e227f3ac5501/clipboard.png" alt="img"></p>
<p>lock接口的实现基本是通过聚合了一个同步器的子类来完成线程访问控制的</p>
<p>同步队列器 -<a href="https://my.oschina.net/oxf1992/blog/837368" target="_blank" rel="external">CLH队列 （</a>AQS里面的CLH队列是CLH同步锁的一种变形）</p>
<p><a href="https://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="external">自旋锁、排队自旋锁、MCS锁、CLH锁</a></p>
<p>重入锁 （支持重入的锁，表示该锁能够支持对一个线程资源的重复加锁）</p>
<p>读写锁 读锁和写锁（缓存）</p>
<p>LockSupport</p>
<p>当需要阻塞或唤醒一个线程的时候，都会使用locksupport工具类来完成响应的工作，LockSupport也成为构建同步组件的基础工具。</p>
<p>Condition接口</p>
<p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、</p>
<p>wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以</p>
<p>实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等</p>
<p>待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9904e58062334f1fb82dbfb1e92bc3ee/clipboard.png" alt="img"></p>
<p>前提都是获取锁</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/9f4bbefa6af647c39f3ca1f843e956ce/clipboard.png" alt="img"></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/050172b8264242efbe768a9daf5d83b1/clipboard.png" alt="img"></p>
<p>使用了locksupport</p>
<p>唤醒操作</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/1076ddd4a8c54c58af5c6eae512db615/clipboard.png" alt="img"></p>
<p>Java并发容器和框架</p>
<p>ConcurrentHashMap</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重</p>
<p>入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数</p>
<p>据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种</p>
<p>数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元</p>
<p>素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，</p>
<p>必须首先获得与它对应的Segment锁，如图6-2所示。</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/acab4c6bd9374b56b2b7667e30583514/clipboard.png" alt="img"></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/415bddd0f0a04e268594f25f0fa6464b/clipboard.png" alt="img"></p>
<p>ConcurrentLinkedQueue</p>
<p>并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两</p>
<p>种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁</p>
<p>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方</p>
<p>式则可以使用循环CAS的方式来实现。本节让我们一起来研究一下Doug Lea是如何使用非阻</p>
<p>塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并</p>
<p>发编程的技巧。</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规</p>
<p>则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元</p>
<p>素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在</p>
<p>Michael&amp;Scott算法上进行了一些修改。</p>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞</p>
<p>的插入和移除方法。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是</p>
<p>从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<p>·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p>
<p>·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</p>
<p>·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</p>
<p>·DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>
<p>·SynchronousQueue：一个不存储元素的阻塞队列。</p>
<p>·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
<p>·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<p>阻塞队列的实现原理</p>
<p>用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生</p>
<p>产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码</p>
<p>发现ArrayBlockingQueue使用了Condition来实现</p>
<p>并发工具类</p>
<p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和</p>
<p>Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数</p>
<p>据的一种手段</p>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<p>join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存</p>
<p>活，如果join线程存活则让当前线程永远等待。其中，wait（0）表示永远等待下去，代码片段如</p>
<p>下。</p>
<p>while (isAlive()) {</p>
<p>wait(0);</p>
<p>}</p>
<p>直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里</p>
<p>实现的，所以在JDK里看不到，大家可以查看JVM源码。</p>
<p>在JDK 1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功</p>
<p>能更多；</p>
<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一</p>
<p>组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会</p>
<p>开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保</p>
<p>存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户</p>
<p>的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日</p>
<p>均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流</p>
<p>水</p>
<p>CyclicBarrier和CountDownLatch的区别</p>
<p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重</p>
<p>置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数</p>
<p>器，并让线程重新执行一次。</p>
<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以</p>
<p>保证合理的使用公共资源。</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假</p>
<p>如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程</p>
<p>并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这</p>
<p>时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连</p>
<p>接。这个时候，就可以使用Semaphore来做流量控制</p>
<p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交</p>
<p>换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过</p>
<p>exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也</p>
<p>执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产</p>
<p>出来的数据传递给对方。</p>
<p>Java中的线程池</p>
<p>当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池</p>
<p>的主要处理流程，处理流程图如图9-1所示。</p>
<p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<p>1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作</p>
<p>线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</p>
<p>2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这</p>
<p>个工作队列里。如果工作队列满了，则进入下个流程。</p>
<p>3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程</p>
<p>来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p>
<p>ThreadPoolExecutor执行execute()方法的示意图，如图9-2所示。</p>
<p>9-1</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/26d5cb5726424f448b1bc0f72c62f932/clipboard.png" alt="img"></p>
<p>9-2</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/46883a882c694ee6a9f826c2c3bd5ecb/clipboard.png" alt="img"></p>
<p>我们可以通过ThreadPoolExecutor来创建一个线程池。</p>
<p>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,</p>
<p>milliseconds,runnableTaskQueue, handler)</p>
<p><a href="https://stackoverflow.com/questions/17660048/threadpoolexecutor-core-and-maximum-pool-sizes" target="_blank" rel="external">https://stackoverflow.com/questions/17660048/threadpoolexecutor-core-and-maximum-pool-sizes</a></p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/d0fcf90b4f22412ca8310e329a442942/clipboard.png" alt="img"></p>
<p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池</p>
<p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>
<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个</p>
<p>future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方</p>
<p>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线</p>
<p>程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<p>Executor框架</p>
<p>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们</p>
<p>为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时，</p>
<p>为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开</p>
<p>来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<p>Executor框架的结构与成员</p>
<p><img src="C:/Users/Administrator/AppData/Local/YNote/data/qq0F67653335B92D2A66852C055AEDBCC5/3e1d05620c68456b8cb44949c74a8960/clipboard.png" alt="img"></p>
<p><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">callable和future</a></p>
<p>FutureTask</p>
<p>11章java并发编程实战</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java 并发编程艺术</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/04/网易云深度学习/" rel="next" title="网易云深度学习">
                <i class="fa fa-chevron-left"></i> 网易云深度学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sinvar</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sinvar</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
